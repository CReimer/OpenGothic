#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_NV_mesh_shader : require
#extension GL_KHR_shader_subgroup_vote: enable

#define MESH
#include "materials_common.glsl"
#include "vertex_process.glsl"

layout(local_size_x = 32) in;
layout(triangles, max_vertices = 64, max_primitives = MaxInd/3) out;

out gl_MeshPerVertexNV {
  vec4 gl_Position;
  } gl_MeshVerticesNV[];

// Custom vertex output block
layout(location = 0) out Varyings shOut[];  // [max_vertices]
#if DEBUG_DRAW
layout(location = DEBUG_DRAW_LOC) out flat uint debugId[];
#endif

shared bool invisible;

void main() {
#if defined(LVL_OBJECT)
  const uint objId     = gl_WorkGroupID.x/push.meshletCount + push.baseInstance;
  const uint meshletId = gl_WorkGroupID.x%push.meshletCount + push.meshletBase;
#else
  const uint objId     = gl_WorkGroupID.x;
  const uint meshletId = gl_WorkGroupID.x;
#endif

  const uint laneID    = gl_LocalInvocationID.x;

#if (MESH_TYPE==T_LANDSCAPE)
  {
  const vec4 sphere = bounds[meshletId];
  invisible = (sphere.w<0.f);
  memoryBarrierShared();
  barrier();
  if(laneID<6) {
    if(dot(vec4(sphere.xyz,1.0), scene.frustrum[laneID]) <= -sphere.w)
      invisible = true;
    }
  memoryBarrierShared();
  barrier();

  if(invisible) {
    if(laneID==0)
      gl_PrimitiveCountNV = 0;
    return;
    }
  }
#elif defined(LVL_OBJECT)
  {
  vec4 sphere = matrix[objId][3];
  sphere.w    = material.bboxRadius;

  invisible = (sphere.w<0.f);
  memoryBarrierShared();
  barrier();
  if(laneID<6) {
    if(dot(vec4(sphere.xyz,1.0), scene.frustrum[laneID]) <= -sphere.w)
      invisible = true;
    }
  memoryBarrierShared();
  barrier();

  if(invisible) {
    if(laneID==0)
      gl_PrimitiveCountNV = 0;
    return;
    }
  }
#else
  // particles
#endif

  const uint vboOffset = meshletId * MaxVert;
  const uint iboOffset = meshletId * MaxInd;

  const Varyings out0 = processVertex(objId, vboOffset + laneID*2 + 0);
  const Varyings out1 = processVertex(objId, vboOffset + laneID*2 + 1);

  shOut            [laneID*2 + 0]             = out0;
  gl_MeshVerticesNV[laneID*2 + 0].gl_Position = out0.scr;
  shOut            [laneID*2 + 1]             = out1;
  gl_MeshVerticesNV[laneID*2 + 1].gl_Position = out1.scr;

#if DEBUG_DRAW
  debugId[laneID*2 + 0] = meshletId;
  debugId[laneID*2 + 1] = meshletId;
#endif

  // Triangle indices [0..123]
  uint index0 = indexes[iboOffset];

  /*
   *  threads 0..30 -> 0..120
   *  thread  31    -> 121..123
   */
  if(laneID<31) {
    gl_PrimitiveIndicesNV[laneID*4 + 0] = indexes[iboOffset + laneID*4 + 0] - index0;
    gl_PrimitiveIndicesNV[laneID*4 + 1] = indexes[iboOffset + laneID*4 + 1] - index0;
    gl_PrimitiveIndicesNV[laneID*4 + 2] = indexes[iboOffset + laneID*4 + 2] - index0;
    }
  if(laneID<30) {
    gl_PrimitiveIndicesNV[laneID*4 + 3] = indexes[iboOffset + laneID*4 + 3] - index0;
    }

  // Number of triangles
  if(laneID==0)
    gl_PrimitiveCountNV = MaxInd/3;
  }
