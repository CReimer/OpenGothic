#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_NV_mesh_shader : require
#extension GL_KHR_shader_subgroup_vote: enable

#define MESH
#include "materials_common.glsl"

layout(local_size_x = 32) in;
layout(triangles, max_vertices = 64, max_primitives = MaxInd/3) out;

out gl_MeshPerVertexNV {
  vec4 gl_Position;
  } gl_MeshVerticesNV[];

// Custom vertex output block
layout(location = 0) out Varyings shOut[];  // [max_vertices]
#if DEBUG_DRAW
layout(location = DEBUG_DRAW_LOC) out flat uint debugId[];
#endif

struct Vertex {
  vec3 pos;
  vec3 norm;
  vec2 uv;
  uint color;
  };

void processVertex(uint objId, uint vboOffset, uint vert) {
  uint id        = (vboOffset + vert)*9;

  vec3 inPos     = vec3(vertices[id + 0], vertices[id + 1], vertices[id + 2]);
  vec3 inNormal  = vec3(vertices[id + 3], vertices[id + 4], vertices[id + 5]);
  vec2 inUV      = vec2(vertices[id + 6], vertices[id + 7]);

#if (MESH_TYPE==T_OBJ || MESH_TYPE==T_MORPH)
  vec3 dpos = vec3(0); //TODO
  inPos     = (matrix[objId]*vec4(inPos+dpos,1.0)).xyz;
  inNormal  = (matrix[objId]*vec4(inNormal,  0.0)).xyz;
#endif

#if defined(MAT_ANIM)
  inUV += material.texAnim;
#endif

  vec4 trPos     = scene.viewProject*vec4(inPos,1.0);
  gl_MeshVerticesNV[vert].gl_Position = trPos;
  shOut[vert].scr                     = trPos;
  shOut[vert].uv                      = inUV;

#if !defined(SHADOW_MAP)
  shOut[vert].shadowPos[0] = scene.shadow[0]*vec4(inPos,1.0);
  shOut[vert].shadowPos[1] = scene.shadow[1]*vec4(inPos,1.0);
  shOut[vert].normal       = inNormal;
#endif

#if !defined(SHADOW_MAP) || defined(WATER)
  shOut[vert].pos = inPos;
#endif

#if defined(MAT_COLOR)
  uint inColor = floatBitsToUint(vertices[id + 8]);
  shOut[vert].color = unpackUnorm4x8(inColor);
#endif
  }

shared bool invisible;

void main() {
#if defined(LVL_OBJECT)
  const uint objId     = gl_WorkGroupID.x/push.meshletCount + push.baseInstance;
  const uint meshletId = gl_WorkGroupID.x%push.meshletCount + push.meshletBase;
#else
  const uint objId     = gl_WorkGroupID.x;
  const uint meshletId = gl_WorkGroupID.x;
#endif

  const uint laneID    = gl_LocalInvocationID.x;

#if (MESH_TYPE==T_LANDSCAPE)
  {
  const vec4 sphere = bounds[meshletId];
  invisible = (sphere.w<0.f);
  memoryBarrierShared();
  barrier();
  if(laneID<6) {
    if(dot(vec4(sphere.xyz,1.0), scene.frustrum[laneID]) <= -sphere.w)
      invisible = true;
    }
  memoryBarrierShared();
  barrier();

  if(invisible) {
    if(laneID==0)
      gl_PrimitiveCountNV = 0;
    return;
    }
  }
#elif defined(LVL_OBJECT)
  {
  vec4 sphere = matrix[objId][3];
  sphere.w    = material.bboxRadius;

  invisible = (sphere.w<0.f);
  memoryBarrierShared();
  barrier();
  if(laneID<6) {
    if(dot(vec4(sphere.xyz,1.0), scene.frustrum[laneID]) <= -sphere.w)
      invisible = true;
    }
  memoryBarrierShared();
  barrier();

  if(invisible) {
    if(laneID==0)
      gl_PrimitiveCountNV = 0;
    return;
    }
  }
#else
  // particles
#endif

  const uint vboOffset = meshletId * MaxVert;
  const uint iboOffset = meshletId * MaxInd;

  processVertex(objId, vboOffset, laneID*2 + 0);
  processVertex(objId, vboOffset, laneID*2 + 1);

#if DEBUG_DRAW
  debugId[laneID*2 + 0] = meshletId;
  debugId[laneID*2 + 1] = meshletId;
#endif

  // Triangle indices [0..123]
  uint index0 = indexes[iboOffset];

  /*
   *  threads 0..30 -> 0..120
   *  thread  31    -> 121..123
   */
  if(laneID<31) {
    gl_PrimitiveIndicesNV[laneID*4 + 0] = indexes[iboOffset + laneID*4 + 0] - index0;
    gl_PrimitiveIndicesNV[laneID*4 + 1] = indexes[iboOffset + laneID*4 + 1] - index0;
    gl_PrimitiveIndicesNV[laneID*4 + 2] = indexes[iboOffset + laneID*4 + 2] - index0;
    }
  if(laneID<30) {
    gl_PrimitiveIndicesNV[laneID*4 + 3] = indexes[iboOffset + laneID*4 + 3] - index0;
    }

  // Number of triangles
  if(laneID==0)
    gl_PrimitiveCountNV = MaxInd/3;
  }
